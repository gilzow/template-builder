---
name: 'Updates'

on:
  push:
    branches:
      - 'auto-updates'
#   schedule:
#     - cron:  "42 7 15 * *" #build project on the 15th day of every month on the 42nd minute of the 7th hour.

env:
    # Update vars.
    UPDATES_BRANCH: 'auto-updater'
    UPDATE_COMMIT_MSG: 'scheduled updates.'
    # Git.
    GITHUB_TOKEN: ${{ secrets.DEVREL_TOKEN }}
    GIT_EMAIL: ${{ secrets.DEVREL_EMAIL }}
    GIT_USER: ${{ secrets.DEVREL_USER }}
    # Notifications.
    SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
    SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
    JOB_ID: 'auto-updates'
    START_MESSAGE: 'Retrieving updates for all templates.'
    JOB_COLOR: "#145CC6"
    # Language-specific tools.
    POETRY_VERSION: "1.1.11"
    PYTHON_VERSION: "3.9"
    RUBY_VERSION: "2.7.4"
    BUNDLER_VERSION: "2.2.26"
    REPOOWNER: "gilzow"
    TEMPLATEOWNER: "gilzow"
    #List of all python-based templates
    PYTHON_TEMPLATES: 'django2 django3 python3 pyramid python3-uwsgi meilisearch flask wagtail pelican'

jobs:
    # A. Get the list of templates that will be used in the update (all subdirectories in `templates/`).
    build:
        runs-on: ubuntu-latest
        name: 'Get templates'
        outputs:
            templates: ${{ steps.getlist.outputs.templates }}
            threadts: ${{ steps.startslack.outputs.threadts }}
        steps:
          - uses: actions/checkout@v2
          - name: Setup Python
            uses: actions/setup-python@v2
            with:
              python-version: ${{ env.PYTHON_VERSION }}
          - name: 'Get template list'
            id: getlist
            run: |
              TEMPLATES=$(python -c '
              import os
              import json
              dirs=os.listdir("{}/templates".format(os.getcwd()))
              dirs.remove("__init__.py")
              test = {"template": dirs}
              print(json.dumps(dirs))
              ')
              echo "::set-output name=templates::$TEMPLATES"
          - name: Install Poetry
            run: |
              python -m pip install poetry==$POETRY_VERSION
          - name: Configure Poetry
            run: |
              python -m poetry config virtualenvs.in-project true
          - name: Cache the virtualenv
            uses: actions/cache@v2
            with:
              path: ./.venv
              key: ${{ runner.os }}-venv-${{ hashFiles('**/poetry.lock') }}
          - name: Install dependencies
            run: |
              python -m poetry install
          - name: 'Start notification on Slack'
            id: startslack
            run: |
              RUN_URL=https://github.com/$REPOOWNER/template-builder/actions/runs/$GITHUB_RUN_ID
              THREAD_ID=$(SLACK_BOT_TOKEN=$SLACK_TOKEN CHANNEL_ID=$SLACK_CHANNEL_ID JOB_ID="$JOB_ID" JOB_COLOR=$JOB_COLOR poetry run python utils/slack_notifier.py start $RUN_URL "$START_MESSAGE")
              echo "::set-output name=threadts::$THREAD_ID"

    # B. Run the update across the templates list.
    update:
        needs: build
        runs-on: ubuntu-latest
        name: 'Template'
        strategy:
            fail-fast: false
            matrix:
                template: ${{fromJSON(needs.build.outputs.templates)}}
                exclude:
                  # PHP
                  - template: 'pimcore'
                  - template: 'symfony5'
                  - template: 'drupal8-opigno'
                  - template: 'drupal8'
                  - template: 'backdrop'
                  - template: 'wordpress-woocommerce'
                  - template: 'magento2ce'
                  - template: 'nextcloud'
                  - template: 'akeneo'
                  - template: 'symfony4'
                  - template: 'wordpress-bedrock'
                  - template: 'typo3'
                  - template: 'wordpress-vanilla'
                  - template: 'drupal8-multisite'
                  - template: 'drupal8-govcms8'
                  - template: 'php'
                  - template: 'laravel'
                  - template: 'wordpress-composer'
                  - template: 'sculpin'
                  # Node.js
                  - template: 'nuxtjs'
                  - template: 'express'
                  - template: 'koa'
                  - template: 'strapi'
                  - template: 'gatsby'
                  - template: 'nodejs'
                  - template: 'probot'
                  - template: 'directus'
                  # Python
                  - template: 'django2'
                  - template: 'django3'
                  - template: 'python3'
                  - template: 'pyramid'
                  - template: 'python3-uwsgi'
                  - template: 'meilisearch'
                  - template: 'flask'
                  - template: 'wagtail'
                  - template: 'pelican'
                  # Go
                  - template: 'mattermost'
                  - template: 'golang'
                  - template: 'beego'
                  - template: 'gin'
                  # Java
                  - template: 'microprofile-wildfly'
                  - template: 'microprofile-openliberty'
                  - template: 'microprofile-helidon'
                  - template: 'microprofile-tomee'
                  - template: 'microprofile-kumuluzee'
                  - template: 'microprofile-thorntail'
                  - template: 'microprofile-payara'
                  - template: 'spring-kotlin'
                  - template: 'spring-boot-gradle-mysql'
                  - template: 'spring-boot-maven-mysql'
                  - template: 'spring-mvc-maven-mongodb'
                  - template: 'tomcat'
                  - template: 'jetty'
                  - template: 'jenkins'
                  - template: 'quarkus'
                  - template: 'xwiki'
                  - template: 'micronaut'
                  # Multi-apps
                  - template: 'gatsby-strapi'
                  - template: 'eleventy-strapi'
                  - template: 'gatsby-wordpress'
                  - template: 'elastic-apm'
                  - template: 'gatsby-drupal'
                  # Lisp
                  - template: 'lisp'
                  # .NET
                  - template: 'aspnet-core'

        steps:
            # Before beginning we need set up all our tools and dependencies
            # 0. Install our tools and dependencies.
            - uses: actions/checkout@v2
            - name: Pre-Start a. Setup Ruby
              uses: actions/setup-ruby@v1
              with:
                ruby-version: ${{ env.RUBY_VERSION }}
            - name: Pre-Start b. Setup Python
              uses: actions/setup-python@v2
              with:
                python-version: ${{ env.PYTHON_VERSION }}
            - name: Pre-Start c. Install Poetry
              run: |
                python -m pip install poetry==$POETRY_VERSION
            - name: Pre-Start d. Configure Poetry
              run: |
                python -m poetry config virtualenvs.in-project true
            - name: Pre-Start e. Cache the virtualenv
              uses: actions/cache@v2
              with:
                path: ./.venv
                key: ${{ runner.os }}-venv-${{ hashFiles('**/poetry.lock') }}
            - name: Pre-Start f. Install dependencies
              run: |
                python -m poetry install

            - name: Pre-Start g. Set default var values
              run: |
                # according to the docs we should be able to set *and update* env vars to pass data between steps
                # @see https://docs.github.com/en/actions/learn-github-actions/workflow-commands-for-github-actions#setting-an-environment-variable
                echo "SLACK_MSG=''" >> $GITHUB_ENV
                echo "PR_STATUS=continue" >> $GITHUB_ENV
            ##########
            # Steps 1 - 5 need to happen regardless if we are going to do an update as we need them to be performed for every
            # template repository
            ###########
            # 1. Make sure the template repo exists
            - name: Step 1. Verify the template repo exists
              id: template-repo-exists
              run: |
                # echo "::set-output name=slack_runurl::https://github.com/${REPOOWNER}/template-builder/actions/runs/${GITHUB_RUN_ID}"
                # Why curl instead of the gh cli? Because on not found, the gh cli will return an exit code of 1 which immediately fails the step and the job
                repoData=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/${TEMPLATEOWNER}/${{ matrix.template }})
                repoID=$(echo "$repoData" | jq '.id')
                repoNodeID=$(echo "$repoData" | jq '.node_id')
                echo "::notice::Repo id - ${repoID}"
                repoFound=$(echo "$repoData" | jq '.message')
                echo "::notice::Repo Found status - ${repoFound}"
                if [[ -z ${repoID} || "${repoFound}" == '"Not Found"'  ]]; then
                    message="The template repo for ${{ matrix.template }} doesn't exist and will need to be created before I can help you."
                    echo "::error::${message}"
                    echo "SLACK_MSG=${message}" >> $GITHUB_ENV
                    echo "SLACK_PRURL=no-pr" >> $GITHUB_ENV
                    echo "SLACK_STATUS=skip" >> $GITHUB_ENV
                    exit 11;
                else
                    echo "::set-output name=repoNodeID::${repoNodeID}"
                fi
            # 2. Verify the repository is set for automerge
            - name: Step 2. Check if auto-merge is enabled for repository
              run: |
                autoMREnabled=$(gh api /repos/${TEMPLATEOWNER}/${{ matrix.template }} --jq '.allow_auto_merge')
                if [[ "${autoMREnabled}" != "true" ]]; then
                  gh api -X PATCH /repos/${TEMPLATEOWNER}/${{ matrix.template }} --field allow_auto_merge=true
                fi

            #3. Get the template repo's default branch
            - name: Step 3. Get template default branch
              id: defaultbranch
              run: |
                # Get the default branch.
                DEFAULT_BRANCH=$(gh api /repos/${TEMPLATEOWNER}/${{ matrix.template }} --jq '.default_branch')
                echo "Our default branch for this template is ${DEFAULT_BRANCH}"
                echo "::set-output name=branch::$DEFAULT_BRANCH"

            # 4. Check if default branch has branch rules in place
            # @todo do we bother to check, or do we just assume it isnt set and attempt to create it anyway? If we attempt to create it and it already
            # exists, it should just return the same values anyway
            - name: Step 4. Add branch protection rules to default branch
              run: |
                # @todo it would be nice if there was some way to verify if the protection rule we need is set and in place instead of always
                # doing this step and step 5 *every time*.
                # For some reason, the following isnt being expanded when we try to use it directly
                defaultBranch=${{ steps.defaultbranch.outputs.branch }}
                repoNodeID=${{ steps.template-repo-exists.outputs.repoNodeID }}
                echo "our default branch is ${defaultBranch}"
                echo "our repoNodeID is ${repoNodeID}"
                # we HAVE to set the number of reviewers to 1 as the API will error otherwise
                #protectBranchJSON='{"required_status_checks":{"strict":true,"contexts":["Fake test"]},"enforce_admins":true,"required_pull_request_reviews":{"dismiss_stale_reviews":true,"require_code_owner_reviews":false,"required_approving_review_count":1},"restrictions":null}'
                # @todo do we need to check if the generation of the branch protection was successful? The API should return a 200 if successful, but at this stage
                # I'm not sure how we access returned response headers from the cli tool
                #echo "${protectBranchJSON}" | gh api -X PUT "/repos/${TEMPLATEOWNER}/${{ matrix.template }}/branches/${defaultBranch}/protection" --input -
                branchProtectionRule="
                    mutation(\$repositoryId:ID!,\$branch:String!) {
                      createBranchProtectionRule(input: {
                        repositoryId: \$repositoryId
                        pattern: \$branch
                        requiresStatusChecks: true
                        requiresStrictStatusChecks: true
                        requiredStatusCheckContexts: [\"Fake test\"]
                        requiresApprovingReviews: true
                        requiredApprovingReviewCount: 0
                        isAdminEnforced: true
                      }) { clientMutationId }
                    }
                "

                gh api graphql -F repositoryId="${repoNodeID}" -F branch="${defaultBranch}" -f query="${branchProtectionRule}"
            # 5. Patch the rule we just created
            #- name: Step 5. Patch the Branch Protection Rule
              #id: branchprotection
              #run: |
                #branchProtectionQuery='query($name: String!, $owner: String!) { repository(owner: $owner, name: $name) { branchProtectionRules(first: 1) { nodes { id } } } }'
                # @todo this assumes the branch protection rule is ALWAYS the first one. Brittle. Also assumes the rule exists
                #branchProtectionID=$(gh api graphql -F owner=${TEMPLATEOWNER} -F name=${{ matrix.template }} -f query="${branchProtectionQuery}" --jq '.data.repository.branchProtectionRules.nodes[0].id')

                #echo "Branch Protection ID: ${branchProtectionID}"

                #if [[ -n "${branchProtectionID}" ]]; then
                  # patch it so the review check is disabled
                  # b = branch, p = protection, r = rule, M (at the end) = mutation
                  #bprUpdateReviewersM="
                    #mutation updateBPR(\$bprID:String!) {
                      #updateBranchProtectionRule(input:{
                        #branchProtectionRuleId: \$bprID,
                        #requiredApprovingReviewCount:0
                      #}) {
                        #branchProtectionRule{
                          #id,
                          #requiredApprovingReviewCount
                        #}
                      #}
                    #}"

                    # @todo should we check for success or just go for it?
                    #gh api graphql -F bprID="${branchProtectionID}" -f query="${bprUpdateReviewersM}"
                #fi
            # 6. Skip early if the update branch already exists (template investigation in progress).
            - name: Step 6. Check if update branch exists on GH
              id: branchstatus
              run: |
                STATUS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/${TEMPLATEOWNER}/${{ matrix.template }}/branches/$UPDATES_BRANCH)
                branchStatus=$( echo $STATUS | jq -r '.message' )

                if [[ 'Branch not found' != "$branchStatus" ]]; then
                  message="Update branch already exists. Skipping template until investigation on open branch (https://github.com/${TEMPLATEOWNER}/${{ matrix.template }}/tree/$UPDATES_BRANCH) is closed."
                  echo "::error::${message}"
                  echo "SLACK_MSG=${message}" >> $GITHUB_ENV
                  echo "SLACK_PRURL=no-pr" >> $GITHUB_ENV
                  echo "SLACK_STATUS=skip" >> $GITHUB_ENV
                  exit 12; # should fail the remaining steps
                fi

                echo "::set-output name=status::$( echo $STATUS | jq -r '.message' )"

            # 7. Run the update tasks through template-builder.
            - name: 'Step 7. Cleanup template build area'
              run: |
                python -m poetry run doit cleanup:${{ matrix.template }}
            # 8.
            - name: 'Step 8. Initialize template build'
              uses: actions/checkout@v2
              with:
                token: ${{ secrets.DEVREL_TOKEN }}
                repository: ${{ env.TEMPLATEOWNER }}/${{ matrix.template }}
                path: templates/${{ matrix.template }}/build
            - name: 'Step 9. Initialize remote'
              run: |
                # Get the remote
                export TEMPLATE=${{ matrix.template }}

                REMOTE_UPSTREAM=$(poetry run python -c '
                import os
                import dodo
                try:
                    print(dodo.project_factory(os.environ["TEMPLATE"]).remote)
                except:
                    print("no remote")
                ')

                # Set up Git.
                cd templates/${{ matrix.template }}/build
                git config --global user.email "$GIT_EMAIL"
                git config --global user.name "$GIT_USER"

                if [ "$REMOTE_UPSTREAM" == "no remote" ]; then
                    echo "$TEMPLATE is type Basic. Skipping remote clone."
                else
                    echo "Upstream found: $REMOTE_UPSTREAM"
                    git remote add project $REMOTE_UPSTREAM
                fi
            - name: 'Step 10. Update template'
              run: |
                # For some reason, in the template-builder app, on first run, python needs a second update before it actually updates
                UPDATES_BRANCH=$UPDATES_BRANCH UPDATE_COMMIT_MSG=$UPDATE_COMMIT_MSG python -m poetry run doit update:${{ matrix.template }}
                if [[ ${PYTHON_TEMPLATES} =~ ${{ matrix.template }} ]]; then
                  UPDATES_BRANCH=$UPDATES_BRANCH UPDATE_COMMIT_MSG=$UPDATE_COMMIT_MSG python -m poetry run doit update:${{ matrix.template }}
                fi
            - name: 'Step 11. Platformify template'
              run: |
                UPDATES_BRANCH=$UPDATES_BRANCH UPDATE_COMMIT_MSG=$UPDATE_COMMIT_MSG python -m poetry run doit platformify:${{ matrix.template }}
            - name: 'Step 12. Branch template'
              run: |
                UPDATES_BRANCH=$UPDATES_BRANCH UPDATE_COMMIT_MSG=$UPDATE_COMMIT_MSG python -m poetry run doit branch:${{ matrix.template }}
            - name: 'Step 13. Push template'
              run: |
                UPDATES_BRANCH=$UPDATES_BRANCH UPDATE_COMMIT_MSG=$UPDATE_COMMIT_MSG python -m poetry run doit push:${{ matrix.template }}

            # 15. Check to see updates have been pushed to a branch.
            - name: Step 14. Check if updates have been pushed
              id: pushstatus
              run: |
                STATUS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/${TEMPLATEOWNER}/${{ matrix.template }}/branches/$UPDATES_BRANCH)
                step11=$( echo $STATUS | jq -r '.message' )
                echo "pushed branch status is ${step11}"

                if [[ "${step11}" = "Branch not found" ]]; then
                  message="The update branch ${UPDATES_BRANCH} for the template ${{ matrix.template }} was not found. Can't create a PR without it."
                  message="${message} Possibly the template had no updates."
                  echo "::error::${message}"
                  echo "SLACK_MSG=${message}" >> $GITHUB_ENV
                  echo "SLACK_PRURL=no-pr" >> $GITHUB_ENV
                  echo "SLACK_STATUS=skip" >> $GITHUB_ENV
                  echo "PR_STATUS=skip" >> $GITHUB_ENV
                  # exit 110; // we dont want to exit as it causes this job to be marked as "failed"
                else
                  echo "::set-output name=status::$( echo $STATUS | jq -r '.message' )"
                  echo "PR_STATUS=continue" >> $GITHUB_ENV
                fi

            - name: 'Step 15. Open pull request'
              id: open-pull-request
              if: env.PR_STATUS != 'skip'
              run: |
                  TITLE="Scheduled updates."
                  BODY="Scheduled updates from template-builder ($(date))."

                  # If successful, the cli will return the URL to the created PR.
                  response=$(gh pr create --head "$UPDATES_BRANCH" --base "${{ steps.defaultbranch.outputs.branch }}" --title "$TITLE" --body "$BODY" --repo ${TEMPLATEOWNER}/${{ matrix.template }})
                  # If the CLI returns 1, the step will fail.
                  boolPRCreated=$?
                  prRegex="([0-9]+$)"
                  if [[ -n "${response}" && $response =~ $prRegex ]]; then
                    PR=${BASH_REMATCH[1]}
                    echo "::set-output name=pull-request-link::$response"
                    echo "::set-output name=pull-request-number::$PR"
                  else
                    echo "cli didn't fail but response is empty or didnt match the regex?"
                    echo "${response}"
                  fi

            # 16. Set the pull request to automerge when checks have passed.
            - name: Step 16. Automatically merge only after necessary requirements are met
              if: env.PR_STATUS != 'skip'
              run: |
                  gh pr merge ${{ steps.open-pull-request.outputs.pull-request-number }} --auto --merge --delete-branch --repo=${TEMPLATEOWNER}/${{ matrix.template }}
                  lastcommand=$?

            # 17. Catch all failures and successes.
            - name: Step 17. Send failed workflows
              if: ${{ failure() }}
              run: |
                  TEMPLATE=${{ matrix.template }}
                  RUN_URL=https://github.com/${REPOOWNER}/template-builder/actions/runs/$GITHUB_RUN_ID
                  THREAD_ID=${{ needs.build.outputs.threadts }}
                  PR_URL=${SLACK_PRURL}
                  MESSAGE="Something went wrong. Investigate.\n${{ env.SLACK_MSG }}"
                  echo "::warning ::I would send the following warning to slack\n${MESSAGE}"
                  RESULT=$(SLACK_BOT_TOKEN=$SLACK_TOKEN CHANNEL_ID=$SLACK_CHANNEL_ID THREAD_ID=$THREAD_ID poetry run python utils/slack_notifier.py down $TEMPLATE "$RUN_URL" "$PR_URL" "$MESSAGE")
            - name: Step 17. Send successfull workflows to the pull request
              if: ${{ success() && steps.branchstatus.outputs.status == 'Branch not found' }}
              run: |
                TEMPLATE=${{ matrix.template }}
                THREAD_ID=${{ needs.build.outputs.threadts }}
                RUN_URL=https://github.com/${REPOOWNER}/template-builder/actions/runs/$GITHUB_RUN_ID

                if [ "${{ steps.pushstatus.outputs.status }}" == "Branch not found" ]; then
                    PR_URL="_Template already up-to-date._"
                else
                    PR_URL="<${{ steps.open-pull-request.outputs.pull-request-link}}|View the pull request>"
                fi

                MESSAGE='All good.'
                RESULT=$(SLACK_BOT_TOKEN=$SLACK_TOKEN CHANNEL_ID=$SLACK_CHANNEL_ID THREAD_ID=$THREAD_ID poetry run python utils/slack_notifier.py up $TEMPLATE "$RUN_URL" "$PR_URL" "$MESSAGE")

    # C. Notify Slack at the end of the run.
    finish:
      runs-on: ubuntu-latest
      name: 'Finish updates'
      needs: [build, update]
      if: ${{ always() }}
      steps:
        - uses: actions/checkout@v2
        - name: Setup Python
          uses: actions/setup-python@v2
          with:
            python-version: ${{ env.PYTHON_VERSION }}
        - name: Install Poetry
          run: |
            python -m pip install poetry==$POETRY_VERSION
        - name: Configure Poetry
          run: |
            python -m poetry config virtualenvs.in-project true
        - name: Cache the virtualenv
          uses: actions/cache@v2
          with:
            path: ./.venv
            key: ${{ runner.os }}-venv-${{ hashFiles('**/poetry.lock') }}
        - name: Install dependencies
          run: |
            python -m poetry install
        - name: 'Notify slack when finished'
          run: |
            THREAD_ID=${{ needs.build.outputs.threadts }}
            RUN_URL=https://github.com/${REPOOWNER}/template-builder/actions/runs/$GITHUB_RUN_ID
            RESULT=$(SLACK_BOT_TOKEN=$SLACK_TOKEN CHANNEL_ID=$SLACK_CHANNEL_ID JOB_ID="$JOB_ID" THREAD_ID=$THREAD_ID JOB_COLOR=$JOB_COLOR poetry run python utils/slack_notifier.py finish $RUN_URL "$START_MESSAGE")
